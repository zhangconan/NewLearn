CPU乱序执行的结果  

x=0,y=1  
![x=0,y=1](./img/x=0,y=1.png)  

x=1,y=0  
![x=1,y=0](./img/x=1,y=0.png)  

x=y=0  
![x=y=0](./img/x=y=0.png)  

出现这几种情况的原因分析： 
 
## 线程之间如何通信？
    线程之间通信机制有两种：共享内存和消息传递。  
### 共享内存
    通过写-读主内存中的变量值进行隐式的通信。  
### 消息传递
    通过发送消息显示进行通信。  
## 线程之间如何同步？
    共享内存模型中，需要在程序中指定某个方法或某段代码需要在线程之间互斥执行。  
    消息传递模型中：消息的发送必须在消息的接收之前。   
## 可见性问题
    java中的并发采用的是共享内存模型的方法。共享内存是什么呢？我们知道JVM中堆内存和方法区(这里区分开来了)是在线程之间共享的。  
    那么这部分内存都包含什么东西呢？包含实例域、静态域、数组元素等。它们又可以称为共享变量。  
    java并发线程之间的通信是由java内存模型(JMM)控制的，JMM决定了一个线程对共享变量的写入何时对另一个线程可见(在默认的情况下，JVM并不要求每个变量在任意时刻都保持同步，这句话很重要！)。JMM可以做这样的一个抽象：  
    线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(或者成为工作内存),本地内存中存储了该线程读-写共享变量的副本。本地内存是JMM的一个抽象概念，
    它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。  
## 写缓冲区
    现代处理器使用写缓冲区临时保存向内存写入的数据，写缓冲区可以保证指令流水线持续运行，  
    它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式  
    刷新写缓冲区，以及合并写缓冲区对同一内存地址的多次写，减少对内存总线的占用。每个处理器上  
    的写缓冲区，仅仅对它所在的处理器可见。这个特性会导致处理器对内存的读/写操作的执行顺序  
    不一定与内存实际发生的读/写操作顺序一致。
JMM抽象模型
  ![JMM抽象模型](./img/JMM抽象模型.png)
JMM硬件映射
  ![JMM硬件](./img/JMM硬件.png)
  
## 线程之间通信
    线程A和线程B之间要通信的话，必须要经历下面这两个步骤：  
    1)、线程A把本地内存A中更新过的共享变量刷新到主内存中去。  
    2)、线程B到主内存中去读取线程A之前已更新过的共享变量。  
    线程间通信如下图所示
  ![线程间通信](./img/线程间通信.png)
  
    具体的通信过程：  
    刚开始时，本地内存A和本地内存B中都保存了一份共享变量X的副本，此时X的值为0。线程A在执行的时候，把更新  
    后的X值(假设值为1)临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改  
    后的X值刷新到主内存中，此时主内存中X的值变为了1，随后，线程B到主内存中去读取线程A更新后的X值，此时，  
    线程B的本地内存的X值也变为了1。
## 缓存一致性协议
    在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线  
    上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前  
    处理器得到缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器  
    缓存行中。
## 重排序  
### 重排序的目的
    提高性能
### 谁会做重排序的动作
    编译器和处理器
### 重排序的分类
    1)、编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。这里需要注意的是：不改变单线程程序的语义。  
    2)、指令级并行的重排序。现代处理器采用了指令级并行技术(ILP)来将多条指令重叠执行。如果不存在数据依赖，处理器可以改变语句对应机器指令的执行顺序。  
    3)、内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。  
    所以从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序  
    源代码---->编译器优化重排序---->指令级并行重排序---->内存系统重排序---->最终执行的指令序列
### 重排序的后果
    可能导致多线程程序出现内存可见性问题。
### 禁止特定类型的处理器重排序 
    通过java编译器在生成指令序列时插入特定类型的内存屏障(Memory Barriers/Memory Fence)。
## 指令重排序
    一条指令的执行是可以分为很多步骤的
        1)、取值 IF
        2)、译码和取寄存器操作数 ID
        3)、执行或者有效地址计算 EX
        4)、存储器访问 MEM
        5)、写回 WB  
     如下图所示(同一个操作不能在两个指令之间进行)
![指令重排(1)](./img/指令重排(1).png)
![指令重排(2)](./img/指令重排(2).png)
![指令重排(3)](./img/指令重排(3).png)
![指令重排(4)](./img/指令重排(4).png)
    


     
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
   
    