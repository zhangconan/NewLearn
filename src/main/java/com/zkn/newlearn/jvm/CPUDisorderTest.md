CPU乱序执行的结果  

x=0,y=1  
![x=0,y=1](./img/x=0,y=1.png)  

x=1,y=0  
![x=1,y=0](./img/x=1,y=0.png)  

x=y=0  
![x=y=0](./img/x=y=0.png)  

出现这几种情况的原因分析： 
 
## 线程之间如何通信？
    线程之间通信机制有两种：共享内存和消息传递。  
### 共享内存
    通过写-读主内存中的变量值进行隐式的通信。  
### 消息传递
    通过发送消息显示进行通信。  
## 线程之间如何同步？
    共享内存模型中，需要在程序中指定某个方法或某段代码需要在线程之间互斥执行。  
    消息传递模型中：消息的发送必须在消息的接收之前。   
## 可见性问题
    java中的并发采用的是共享内存模型的方法。共享内存是什么呢？我们知道JVM中堆内存和方法区(这里区分开来了)是在线程之间共享的。  
    那么这部分内存都包含什么东西呢？包含实例域、静态域、数组元素等。它们又可以称为共享变量。  
    java并发线程之间的通信是由java内存模型(JMM)控制的，JMM决定了一个线程对共享变量的写入何时对另一个线程可见(在默认的情况下，JVM并不要求每个变量在任意时刻都保持同步，这句话很重要！)。JMM可以做这样的一个抽象：  
    线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(或者成为工作内存),本地内存中存储了该线程读-写共享变量的副本。本地内存是JMM的一个抽象概念，
    它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。  
    
JMM抽象模型
  ![JMM抽象模型](./img/JMM抽象模型.png)
JMM硬件映射
  ![JMM硬件](./img/JMM硬件.png)
  
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
   
    